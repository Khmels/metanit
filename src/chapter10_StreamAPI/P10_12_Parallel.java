package chapter10_StreamAPI;

import java.util.*;
import java.util.stream.Stream;

public class P10_12_Parallel {
    public static void main(String[] args) {

        Stream<Integer> numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
        Optional<Integer> result = numbersStream.parallel().reduce((x, y)-> x*y);
        System.out.println(result.get()); // 720
        System.out.println("---------------------");

        /*
        Однако не все функции можно без ущерба для точности вычисления перенести с последовательных потоков на параллельные.

        Прежде всего такие функции должны быть без сохранения состояния и ассоциативными,
        то есть при выполнении слева направо давать тот же результат,
        что и при выполнении справа налево, как в случае с произведением чисел.
         */

        Stream<String> wordsStream = Stream.of("Введение", "в", "Stream", "API");
        String sentence = wordsStream.parallel().reduce("Результат:", (x,y)->x + " " + y);
        System.out.println(sentence);
        System.out.println("---------------------");

        /*
        Данный вывод не является правильным.
        Если же нет уверенностью, что на каком-то этапе работы с параллельным потоком
        он адекватно сможет выполнить какую-нибудь операцию,
        то можно преобразовать этот поток в последовательный посредством вызова метода sequential():
         */

        Stream<String> wordsStream2 = Stream.of("Введение", "в", "Stream", "API");

        // Redundant 'parallel' call: there's subsequent 'sequential' call which overrides this call
        String sentence2 = wordsStream2.parallel()
                .filter(s->s.length()<10) // фильтрация над параллельным потоком
                .sequential()
                .reduce("Результат:", (x,y)->x + " " + y); // операция над последовательным потоком
        System.out.println(sentence2);
        System.out.println("---------------------");

        /*
        Фактически здесь происходит перемножение чисел.
        При этом нет разницы между 1 * 2 * 3 * 4 * (5 * 6) или 5 * 6 * 1 * (2 * 3) * 4.

        Можно расставить скобки любым образом, разместить последовательность чисел в любом порядке,
        и все равно получить один и тот же результат.

        То есть данная операция является ассоциативной и поэтому может быть распараллелена.
         */

        //--- Упорядоченность в параллельных потоках

        /*
        Как правило, элементы передаются в поток в том же порядке, в котором они определены в источнике данных.
        ПРИ РАБОТЕ С ПАРАЛЛЕЛЬНЫМИ ПОТОКАМИ СИСТЕМА СОХРАНЯЕТ ПОРЯДОК СЛЕДОВАНИЯ ЭЛЕМЕНТОВ.

        Исключение составляет метод forEach(), который может выводить элементы в произвольном порядке.
         */

        /*
        Чтобы сохранить порядок следования, необходимо применять метод forEachOrdered:
         */

        List<String> phonesList = new ArrayList<String>();
        Collections.addAll(phonesList, "iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2",
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");

        phonesList.parallelStream()
                .sorted()
                .forEachOrdered(s->System.out.println(s));
        System.out.println("---------------------");

        // обычный - не дает порядок
        List<String> phonesList2 = new ArrayList<String>();
        Collections.addAll(phonesList2, "iPhone 8", "HTC U12", "Huawei Nexus 6P",
                "Samsung Galaxy S9", "LG G6", "Xiaomi MI6", "ASUS Zenfone 2",
                "Sony Xperia Z5", "Meizu Pro 6", "Lenovo S850");

        phonesList2.parallelStream()
                .sorted()
                .forEach(s->System.out.println(s));
        System.out.println("---------------------");

        /*
        Сохранение порядка в параллельных потоках увеличивает издержки при выполнении.
        Но если порядок не важен, то мы можем отключить его сохранение
        и тем самым увеличить производительность, использовав метод unordered:
         */

        phonesList2.parallelStream()
                .sorted()
                .unordered()
                .forEach(s->System.out.println(s));
    }
}

/*
Кроме последовательных потоков Stream API поддерживает параллельные потоки.
Распараллеливание потоков позволяет задействовать несколько ядер процессора (если целевая машина многоядерная)
и тем самым может повысить производительность и ускорить вычисления.

В то же время говорить, что применение параллельных потоков на многоядерных машинах однозначно
повысит производительность - не совсем корректно. В каждом конкретном случае надо проверять и тестировать.

Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel.
Кроме того, можно также использовать метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции.

В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный
 */

/*
Вопросы производительности в параллельных операциях

Фактически применение параллельных потоков сводится к тому,
что данные в потоке будут разделены на части,
каждая часть обрабатывается на отдельном ядре процессора,
и в конце эти части соединяются, и над ними выполняются финальные операции.
*/

/*
Рассмотрим некоторые критерии, которые могут повлиять на производительность в параллельных потоках:

- Размер данных. Чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.

- Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. \
    Если на машине одно ядро, нет смысла применять параллельные потоки.

- Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции.
    Например, данные из ArrayList легко использовать,
    так как структура данной коллекции предполагает последовательность несвязанных данных.

    А вот коллекция типа LinkedList - не лучший вариант,
    так как в последовательном списке все элементы связаны с предыдущими/последующими.
    И такие данные трудно распараллелить.

- Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов
 */
